설명1

게임 만들러 왔는데 왜 이중 for문 같은 걸 해야 하나?
내가 지금 하고 있는 프로젝트를 예시로 보여주자.
월드 상에 동적으로 오브젝트를 스폰하는 숙제를 내 줄 것임.
그때는 3중 for문이다!

게임 만들러 왔는데 왜 이런걸 알아야 하나?
게임 ==  현대 기술로 치면 우주선 발사 (삶을 유지하는데에 그렇게 큰 영향을 미치지 않지만, 신기하게도 온 힘을 모아서 발전시키려고 하는 분야.)
첫째로, 현대의 가장 진보된 기술이 게임에 쓰인다는 점에서 그렇고, 
둘째로, 게임에서 성장한 기술들이 게임 이외의 분야에서도 많이 쓰인다는 점에서 그러하다.
다만... 이것을 배울 때 전부 다 삼키겠다는 생각은 금물. 
지금 들어두었다가 면접 다가와서 책 찾아보면 된다.
그때는 책에서 설명해주는 내용이 이해가 잘 될 것임.

1. 메모리 위계 - 앞의 것은 물리적인메모리 위계, 메모리에서 나뉘는 네가지 저장공간은 가상의 논리적 분할이다. 
(이 논리적 분할이 지켜지지 않으면 SW가 오작동을 일으키게 된다.)
	ㅅ  레지스터
	 |  캐시
	 |  메모리------ 코드: 컴파일 타임에 결정되고 저장된다. 실행을 하면 기계어로 번역되어 저장된 코드를 읽어온다. 리드온리.
	 |  하드	  |
	 V	  | -- 데이터: 전역/static 변수 등 프로그램이 사용하는 데이터가 저장되는 곳. 
		  |		컴파일이 완료되면 코드는 전역/static 변수의 주소값을 가리킨다. 런타임 도중 변경 가능. 
		  |
		  | -- 힙: 동적할당이 이루어지는 곳. 런타임 도중에 수시로 바뀐다.
		  |
		  | -- 스택 : 정적할당이 이루어지는 곳. 이 정적할당은 컴파일 타임에 정해진다. 
				어느 실행 위치에서 얼마만큼 할당할지 이미 예측이 되는 상태에서 런타임으로 진입한다.

메모리 위계에서... 
위로 갈 수록 비싸고 빠르다. 연산장치에 가까워진다.
아래로 갈 수록 싸고 느리다. 연산장치에서 멀어진다.


2. 프로그램과 프로세스: 프로그램은 하드에 저장된 파일을 말한다. 가만히 내비두면 아무런 일도 일어나지 않음/프로세스는 이를 실행하는 걸 말함.

<컴파일타임>
우리가 코드를 쓰고 컴퓨터가 읽음.
빨간줄 -> 컴퓨터가 읽을 수 없다는 뜻. == 컴파일 에러
이 컴파일 타임에 지역변수가 할당됨
디버깅하면서 이를 알 수 있음. 
(실습)아직 main()의 중괄호에 들어가지도 않았는데 선언한 변수의 자리가 할당되고 거기에 쓰레기 값이 들어간 것을 확인했음.
런타임에 진입하면 더이상 편집이 불가능함! 

<런타임>
Ctrl + F5를 통해 프로그램을 실행하고나서 종료될 때까지의 시간
메인함수의 중괄호의 범위가 런타임의 범위이다.
여기서 생기는 오류는 런타임 에러, 버그라고 칭함. 예를 들어 스택 오버플로우. 컴파일은 잘 되는데 실행 중에 오작동함. -> 스택오버플로우를 만드는 법을 알려주자.


3. 정적(Static), 동적(Dynamic)
대부분의 프로그래밍 언어에서 많이 사용하는 용어.
언어가 아니더라도 SW 개발 분야에서 흔히 사용한다.
정적은, 미리 만들어 놓고 고정적으로 쓴다는 뜻.
동적은, 필요할 때마다 생성한다는 뜻. 

우리가 지금까지 쓴 것들은 전부 정적할당임. 보통 우리가 변수를 선언하고 사용하는 행위는 대부분 정적할당이다.
지역변수, 매개변수, 리턴값 등이 모든 이 정적할당으로 된다. 컴파일타임에 메모리에 공간이 만들어지고, 그 변수가 속한 중괄호 영역을 실행중이 아니더라도 그 공간이 그대로 있다.
동적으로 (malloc을 통해) 프로그래머가 프로그램 실행 전에 메모리할당을 직접 명령하면, 런타임 도중에 이 메모리공간이 할당되고 (delete와 free()를 통해) 해제된다. 이를 동적할당이라 부른다. 
메모리 공간이 할당은 되지만, 여기에 진짜 정보를 채워넣는건 런타임 시에 변경될 수 있음. 그리고 다른 변수가 이 영역을 침범할 수 없음.
그럼 왜 메모리를 할당하는 걸 고려해야 할까? 비싸서!
이를 배열의 예를 통해 설명해 주자.

C/C++언어에선 동적할당을 할 때 일일이 코드로 써줘야 한다. 
얼마만큼 메모리를 쓰겠다! 안쓰는 동적 변수는 메모리를 해제해서 힙 메모리를 아끼겠다! 이런 식으로.
근데 언리얼에서는 개발자들의 편의를 위해 GC를 제공. 이 가비지 컬렉터는, 변수를 특정 타이밍이 지나서도 쓸 일이 생기지 않으면 메모리를 해제한다. 
그러므로 CS 지식이 없어도 개발을 잘 할 수 있음.
하지만 서버로 오면... 얘기가 달라짐. 

다만 우리가 앞서 배운 static 지역 변수는 다른 개념이다. 이는 변수의 수명을 가리키는 의미에서 정적이다.
즉 중괄호를 벗어나도 그 변수의 공간과 값이 메모리의 데이터 영역에 유지되며 두번다시 초기화되지 않는다는 의미임.